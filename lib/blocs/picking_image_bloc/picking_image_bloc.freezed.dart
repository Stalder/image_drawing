// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'picking_image_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PickingImageEventTearOff {
  const _$PickingImageEventTearOff();

  _PickingImageEventFetchFromNetwork fetchFromNetwork() {
    return const _PickingImageEventFetchFromNetwork();
  }
}

/// @nodoc
const $PickingImageEvent = _$PickingImageEventTearOff();

/// @nodoc
mixin _$PickingImageEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchFromNetwork,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchFromNetwork,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageEventFetchFromNetwork value)
        fetchFromNetwork,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageEventFetchFromNetwork value)?
        fetchFromNetwork,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PickingImageEventCopyWith<$Res> {
  factory $PickingImageEventCopyWith(
          PickingImageEvent value, $Res Function(PickingImageEvent) then) =
      _$PickingImageEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$PickingImageEventCopyWithImpl<$Res>
    implements $PickingImageEventCopyWith<$Res> {
  _$PickingImageEventCopyWithImpl(this._value, this._then);

  final PickingImageEvent _value;
  // ignore: unused_field
  final $Res Function(PickingImageEvent) _then;
}

/// @nodoc
abstract class _$PickingImageEventFetchFromNetworkCopyWith<$Res> {
  factory _$PickingImageEventFetchFromNetworkCopyWith(
          _PickingImageEventFetchFromNetwork value,
          $Res Function(_PickingImageEventFetchFromNetwork) then) =
      __$PickingImageEventFetchFromNetworkCopyWithImpl<$Res>;
}

/// @nodoc
class __$PickingImageEventFetchFromNetworkCopyWithImpl<$Res>
    extends _$PickingImageEventCopyWithImpl<$Res>
    implements _$PickingImageEventFetchFromNetworkCopyWith<$Res> {
  __$PickingImageEventFetchFromNetworkCopyWithImpl(
      _PickingImageEventFetchFromNetwork _value,
      $Res Function(_PickingImageEventFetchFromNetwork) _then)
      : super(_value, (v) => _then(v as _PickingImageEventFetchFromNetwork));

  @override
  _PickingImageEventFetchFromNetwork get _value =>
      super._value as _PickingImageEventFetchFromNetwork;
}

/// @nodoc
class _$_PickingImageEventFetchFromNetwork
    implements _PickingImageEventFetchFromNetwork {
  const _$_PickingImageEventFetchFromNetwork();

  @override
  String toString() {
    return 'PickingImageEvent.fetchFromNetwork()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PickingImageEventFetchFromNetwork);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() fetchFromNetwork,
  }) {
    return fetchFromNetwork();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? fetchFromNetwork,
    required TResult orElse(),
  }) {
    if (fetchFromNetwork != null) {
      return fetchFromNetwork();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageEventFetchFromNetwork value)
        fetchFromNetwork,
  }) {
    return fetchFromNetwork(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageEventFetchFromNetwork value)?
        fetchFromNetwork,
    required TResult orElse(),
  }) {
    if (fetchFromNetwork != null) {
      return fetchFromNetwork(this);
    }
    return orElse();
  }
}

abstract class _PickingImageEventFetchFromNetwork implements PickingImageEvent {
  const factory _PickingImageEventFetchFromNetwork() =
      _$_PickingImageEventFetchFromNetwork;
}

/// @nodoc
class _$PickingImageStateTearOff {
  const _$PickingImageStateTearOff();

  _PickingImageStateInitial initial() {
    return const _PickingImageStateInitial();
  }

  _PickingImageStatePending pending() {
    return const _PickingImageStatePending();
  }

  _PickingImageStateSucceeded succeeded() {
    return const _PickingImageStateSucceeded();
  }

  _PickingImageStateFailed failed() {
    return const _PickingImageStateFailed();
  }
}

/// @nodoc
const $PickingImageState = _$PickingImageStateTearOff();

/// @nodoc
mixin _$PickingImageState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() pending,
    required TResult Function() succeeded,
    required TResult Function() failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? pending,
    TResult Function()? succeeded,
    TResult Function()? failed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageStateInitial value) initial,
    required TResult Function(_PickingImageStatePending value) pending,
    required TResult Function(_PickingImageStateSucceeded value) succeeded,
    required TResult Function(_PickingImageStateFailed value) failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageStateInitial value)? initial,
    TResult Function(_PickingImageStatePending value)? pending,
    TResult Function(_PickingImageStateSucceeded value)? succeeded,
    TResult Function(_PickingImageStateFailed value)? failed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PickingImageStateCopyWith<$Res> {
  factory $PickingImageStateCopyWith(
          PickingImageState value, $Res Function(PickingImageState) then) =
      _$PickingImageStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PickingImageStateCopyWithImpl<$Res>
    implements $PickingImageStateCopyWith<$Res> {
  _$PickingImageStateCopyWithImpl(this._value, this._then);

  final PickingImageState _value;
  // ignore: unused_field
  final $Res Function(PickingImageState) _then;
}

/// @nodoc
abstract class _$PickingImageStateInitialCopyWith<$Res> {
  factory _$PickingImageStateInitialCopyWith(_PickingImageStateInitial value,
          $Res Function(_PickingImageStateInitial) then) =
      __$PickingImageStateInitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$PickingImageStateInitialCopyWithImpl<$Res>
    extends _$PickingImageStateCopyWithImpl<$Res>
    implements _$PickingImageStateInitialCopyWith<$Res> {
  __$PickingImageStateInitialCopyWithImpl(_PickingImageStateInitial _value,
      $Res Function(_PickingImageStateInitial) _then)
      : super(_value, (v) => _then(v as _PickingImageStateInitial));

  @override
  _PickingImageStateInitial get _value =>
      super._value as _PickingImageStateInitial;
}

/// @nodoc
class _$_PickingImageStateInitial implements _PickingImageStateInitial {
  const _$_PickingImageStateInitial();

  @override
  String toString() {
    return 'PickingImageState.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PickingImageStateInitial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() pending,
    required TResult Function() succeeded,
    required TResult Function() failed,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? pending,
    TResult Function()? succeeded,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageStateInitial value) initial,
    required TResult Function(_PickingImageStatePending value) pending,
    required TResult Function(_PickingImageStateSucceeded value) succeeded,
    required TResult Function(_PickingImageStateFailed value) failed,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageStateInitial value)? initial,
    TResult Function(_PickingImageStatePending value)? pending,
    TResult Function(_PickingImageStateSucceeded value)? succeeded,
    TResult Function(_PickingImageStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _PickingImageStateInitial implements PickingImageState {
  const factory _PickingImageStateInitial() = _$_PickingImageStateInitial;
}

/// @nodoc
abstract class _$PickingImageStatePendingCopyWith<$Res> {
  factory _$PickingImageStatePendingCopyWith(_PickingImageStatePending value,
          $Res Function(_PickingImageStatePending) then) =
      __$PickingImageStatePendingCopyWithImpl<$Res>;
}

/// @nodoc
class __$PickingImageStatePendingCopyWithImpl<$Res>
    extends _$PickingImageStateCopyWithImpl<$Res>
    implements _$PickingImageStatePendingCopyWith<$Res> {
  __$PickingImageStatePendingCopyWithImpl(_PickingImageStatePending _value,
      $Res Function(_PickingImageStatePending) _then)
      : super(_value, (v) => _then(v as _PickingImageStatePending));

  @override
  _PickingImageStatePending get _value =>
      super._value as _PickingImageStatePending;
}

/// @nodoc
class _$_PickingImageStatePending implements _PickingImageStatePending {
  const _$_PickingImageStatePending();

  @override
  String toString() {
    return 'PickingImageState.pending()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PickingImageStatePending);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() pending,
    required TResult Function() succeeded,
    required TResult Function() failed,
  }) {
    return pending();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? pending,
    TResult Function()? succeeded,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageStateInitial value) initial,
    required TResult Function(_PickingImageStatePending value) pending,
    required TResult Function(_PickingImageStateSucceeded value) succeeded,
    required TResult Function(_PickingImageStateFailed value) failed,
  }) {
    return pending(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageStateInitial value)? initial,
    TResult Function(_PickingImageStatePending value)? pending,
    TResult Function(_PickingImageStateSucceeded value)? succeeded,
    TResult Function(_PickingImageStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (pending != null) {
      return pending(this);
    }
    return orElse();
  }
}

abstract class _PickingImageStatePending implements PickingImageState {
  const factory _PickingImageStatePending() = _$_PickingImageStatePending;
}

/// @nodoc
abstract class _$PickingImageStateSucceededCopyWith<$Res> {
  factory _$PickingImageStateSucceededCopyWith(
          _PickingImageStateSucceeded value,
          $Res Function(_PickingImageStateSucceeded) then) =
      __$PickingImageStateSucceededCopyWithImpl<$Res>;
}

/// @nodoc
class __$PickingImageStateSucceededCopyWithImpl<$Res>
    extends _$PickingImageStateCopyWithImpl<$Res>
    implements _$PickingImageStateSucceededCopyWith<$Res> {
  __$PickingImageStateSucceededCopyWithImpl(_PickingImageStateSucceeded _value,
      $Res Function(_PickingImageStateSucceeded) _then)
      : super(_value, (v) => _then(v as _PickingImageStateSucceeded));

  @override
  _PickingImageStateSucceeded get _value =>
      super._value as _PickingImageStateSucceeded;
}

/// @nodoc
class _$_PickingImageStateSucceeded implements _PickingImageStateSucceeded {
  const _$_PickingImageStateSucceeded();

  @override
  String toString() {
    return 'PickingImageState.succeeded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PickingImageStateSucceeded);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() pending,
    required TResult Function() succeeded,
    required TResult Function() failed,
  }) {
    return succeeded();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? pending,
    TResult Function()? succeeded,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (succeeded != null) {
      return succeeded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageStateInitial value) initial,
    required TResult Function(_PickingImageStatePending value) pending,
    required TResult Function(_PickingImageStateSucceeded value) succeeded,
    required TResult Function(_PickingImageStateFailed value) failed,
  }) {
    return succeeded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageStateInitial value)? initial,
    TResult Function(_PickingImageStatePending value)? pending,
    TResult Function(_PickingImageStateSucceeded value)? succeeded,
    TResult Function(_PickingImageStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (succeeded != null) {
      return succeeded(this);
    }
    return orElse();
  }
}

abstract class _PickingImageStateSucceeded implements PickingImageState {
  const factory _PickingImageStateSucceeded() = _$_PickingImageStateSucceeded;
}

/// @nodoc
abstract class _$PickingImageStateFailedCopyWith<$Res> {
  factory _$PickingImageStateFailedCopyWith(_PickingImageStateFailed value,
          $Res Function(_PickingImageStateFailed) then) =
      __$PickingImageStateFailedCopyWithImpl<$Res>;
}

/// @nodoc
class __$PickingImageStateFailedCopyWithImpl<$Res>
    extends _$PickingImageStateCopyWithImpl<$Res>
    implements _$PickingImageStateFailedCopyWith<$Res> {
  __$PickingImageStateFailedCopyWithImpl(_PickingImageStateFailed _value,
      $Res Function(_PickingImageStateFailed) _then)
      : super(_value, (v) => _then(v as _PickingImageStateFailed));

  @override
  _PickingImageStateFailed get _value =>
      super._value as _PickingImageStateFailed;
}

/// @nodoc
class _$_PickingImageStateFailed implements _PickingImageStateFailed {
  const _$_PickingImageStateFailed();

  @override
  String toString() {
    return 'PickingImageState.failed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PickingImageStateFailed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() pending,
    required TResult Function() succeeded,
    required TResult Function() failed,
  }) {
    return failed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? pending,
    TResult Function()? succeeded,
    TResult Function()? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PickingImageStateInitial value) initial,
    required TResult Function(_PickingImageStatePending value) pending,
    required TResult Function(_PickingImageStateSucceeded value) succeeded,
    required TResult Function(_PickingImageStateFailed value) failed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PickingImageStateInitial value)? initial,
    TResult Function(_PickingImageStatePending value)? pending,
    TResult Function(_PickingImageStateSucceeded value)? succeeded,
    TResult Function(_PickingImageStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class _PickingImageStateFailed implements PickingImageState {
  const factory _PickingImageStateFailed() = _$_PickingImageStateFailed;
}
